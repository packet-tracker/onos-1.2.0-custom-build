<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>OpenFlowDeviceProvider.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">onos-of-provider-device</a> &gt; <a href="index.source.html" class="el_package">org.onosproject.provider.of.device.impl</a> &gt; <span class="el_source">OpenFlowDeviceProvider.java</span></div><h1>OpenFlowDeviceProvider.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014-2015 Open Networking Laboratory
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.onosproject.provider.of.device.impl;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Strings.isNullOrEmpty;
import static org.onlab.util.Tools.get;
import static org.onosproject.net.DeviceId.deviceId;
import static org.onosproject.net.Port.Type.COPPER;
import static org.onosproject.net.Port.Type.FIBER;
import static org.onosproject.openflow.controller.Dpid.dpid;
import static org.onosproject.openflow.controller.Dpid.uri;
import static org.slf4j.LoggerFactory.getLogger;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Dictionary;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

import org.apache.felix.scr.annotations.Activate;
import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Deactivate;
import org.apache.felix.scr.annotations.Modified;
import org.apache.felix.scr.annotations.Property;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.ReferenceCardinality;
import org.onlab.packet.ChassisId;
import org.onlab.util.Frequency;
import org.onlab.util.Spectrum;
import org.onosproject.cfg.ComponentConfigService;
import org.onosproject.net.AnnotationKeys;
import org.onosproject.net.ChannelSpacing;
import org.onosproject.net.DefaultAnnotations;
import org.onosproject.net.Device;
import org.onosproject.net.DeviceId;
import org.onosproject.net.GridType;
import org.onosproject.net.MastershipRole;
import org.onosproject.net.OchSignal;
import org.onosproject.net.OduCltPort;
import org.onosproject.net.OduSignalType;
import org.onosproject.net.Port;
import org.onosproject.net.PortNumber;
import org.onosproject.net.SparseAnnotations;
import org.onosproject.net.device.DefaultDeviceDescription;
import org.onosproject.net.device.DefaultPortDescription;
import org.onosproject.net.device.DefaultPortStatistics;
import org.onosproject.net.device.DeviceDescription;
import org.onosproject.net.device.DeviceProvider;
import org.onosproject.net.device.DeviceProviderRegistry;
import org.onosproject.net.device.DeviceProviderService;
import org.onosproject.net.device.OchPortDescription;
import org.onosproject.net.device.OduCltPortDescription;
import org.onosproject.net.device.OmsPortDescription;
import org.onosproject.net.device.PortDescription;
import org.onosproject.net.device.PortStatistics;
import org.onosproject.net.provider.AbstractProvider;
import org.onosproject.net.provider.ProviderId;
import org.onosproject.openflow.controller.Dpid;
import org.onosproject.openflow.controller.OpenFlowController;
import org.onosproject.openflow.controller.OpenFlowEventListener;
import org.onosproject.openflow.controller.OpenFlowOpticalSwitch;
import org.onosproject.openflow.controller.OpenFlowSwitch;
import org.onosproject.openflow.controller.OpenFlowSwitchListener;
import org.onosproject.openflow.controller.PortDescPropertyType;
import org.onosproject.openflow.controller.RoleState;
import org.osgi.service.component.ComponentContext;
import org.projectfloodlight.openflow.protocol.OFCalientPortDescStatsEntry;
import org.projectfloodlight.openflow.protocol.OFExpPort;
import org.projectfloodlight.openflow.protocol.OFExpPortDescPropOpticalTransport;
import org.projectfloodlight.openflow.protocol.OFExpPortOpticalTransportLayerEntry;
import org.projectfloodlight.openflow.protocol.OFFactory;
import org.projectfloodlight.openflow.protocol.OFMessage;
import org.projectfloodlight.openflow.protocol.OFObject;
import org.projectfloodlight.openflow.protocol.OFPortConfig;
import org.projectfloodlight.openflow.protocol.OFPortDesc;
import org.projectfloodlight.openflow.protocol.OFPortDescPropOpticalTransport;
import org.projectfloodlight.openflow.protocol.OFPortFeatures;
import org.projectfloodlight.openflow.protocol.OFPortOptical;
import org.projectfloodlight.openflow.protocol.OFPortOpticalTransportLayerClass;
import org.projectfloodlight.openflow.protocol.OFPortOpticalTransportSignalType;
import org.projectfloodlight.openflow.protocol.OFPortReason;
import org.projectfloodlight.openflow.protocol.OFPortState;
import org.projectfloodlight.openflow.protocol.OFPortStatsEntry;
import org.projectfloodlight.openflow.protocol.OFPortStatsReply;
import org.projectfloodlight.openflow.protocol.OFPortStatus;
import org.projectfloodlight.openflow.protocol.OFStatsReply;
import org.projectfloodlight.openflow.protocol.OFStatsReplyFlags;
import org.projectfloodlight.openflow.protocol.OFStatsType;
import org.projectfloodlight.openflow.protocol.OFVersion;
import org.projectfloodlight.openflow.types.PortSpeed;
import org.slf4j.Logger;

import com.google.common.base.Strings;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

/**
 * Provider which uses an OpenFlow controller to detect network
 * infrastructure devices.
 */
@Component(immediate = true)
public class OpenFlowDeviceProvider extends AbstractProvider implements DeviceProvider {

<span class="fc" id="L121">    private static final Logger LOG = getLogger(OpenFlowDeviceProvider.class);</span>

    private static final long MBPS = 1_000 * 1_000;
<span class="fc" id="L124">    private static final Frequency FREQ100 = Frequency.ofGHz(100);</span>
<span class="fc" id="L125">    private static final Frequency FREQ193_1 = Frequency.ofTHz(193.1);</span>
<span class="fc" id="L126">    private static final Frequency FREQ4_4 = Frequency.ofTHz(4.4);</span>

    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected DeviceProviderRegistry providerRegistry;

    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected OpenFlowController controller;

    @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
    protected ComponentConfigService cfgService;

    private DeviceProviderService providerService;

<span class="fc" id="L139">    private final InternalDeviceProvider listener = new InternalDeviceProvider();</span>

    // TODO: We need to make the poll interval configurable.
    static final int POLL_INTERVAL = 5;
<span class="fc" id="L143">    @Property(name = &quot;PortStatsPollFrequency&quot;, intValue = POLL_INTERVAL,</span>
    label = &quot;Frequency (in seconds) for polling switch Port statistics&quot;)
    private int portStatsPollFrequency = POLL_INTERVAL;

<span class="fc" id="L147">    private HashMap&lt;Dpid, PortStatsCollector&gt; collectors = Maps.newHashMap();</span>

    /**
     * Creates an OpenFlow device provider.
     */
    public OpenFlowDeviceProvider() {
<span class="fc" id="L153">        super(new ProviderId(&quot;of&quot;, &quot;org.onosproject.provider.openflow&quot;));</span>
<span class="fc" id="L154">    }</span>

    @Activate
    public void activate(ComponentContext context) {
<span class="fc" id="L158">        cfgService.registerProperties(getClass());</span>
<span class="fc" id="L159">        providerService = providerRegistry.register(this);</span>
<span class="fc" id="L160">        controller.addListener(listener);</span>
<span class="fc" id="L161">        controller.addEventListener(listener);</span>
<span class="fc" id="L162">        connectInitialDevices();</span>
<span class="fc" id="L163">        LOG.info(&quot;Started&quot;);</span>
<span class="fc" id="L164">    }</span>

    @Deactivate
    public void deactivate(ComponentContext context) {
<span class="fc" id="L168">        cfgService.unregisterProperties(getClass(), false);</span>
<span class="fc" id="L169">        controller.removeListener(listener);</span>
<span class="fc" id="L170">        disconnectDevices();</span>
<span class="fc" id="L171">        providerRegistry.unregister(this);</span>
<span class="fc" id="L172">        collectors.values().forEach(PortStatsCollector::stop);</span>
<span class="fc" id="L173">        providerService = null;</span>
<span class="fc" id="L174">        LOG.info(&quot;Stopped&quot;);</span>
<span class="fc" id="L175">    }</span>

    @Modified
    public void modified(ComponentContext context) {
<span class="nc" id="L179">        Dictionary&lt;?, ?&gt; properties = context.getProperties();</span>
        int newPortStatsPollFrequency;
        try {
<span class="nc" id="L182">            String s = get(properties, &quot;PortStatsPollFrequency&quot;);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">            newPortStatsPollFrequency = isNullOrEmpty(s) ? portStatsPollFrequency : Integer.parseInt(s.trim());</span>

<span class="nc" id="L185">        } catch (NumberFormatException | ClassCastException e) {</span>
<span class="nc" id="L186">            newPortStatsPollFrequency = portStatsPollFrequency;</span>
<span class="nc" id="L187">        }</span>

<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (newPortStatsPollFrequency != portStatsPollFrequency) {</span>
<span class="nc" id="L190">            portStatsPollFrequency = newPortStatsPollFrequency;</span>
<span class="nc" id="L191">            collectors.values().forEach(psc -&gt; psc.adjustPollInterval(portStatsPollFrequency));</span>
        }

<span class="nc" id="L194">        LOG.info(&quot;Settings: portStatsPollFrequency={}&quot;, portStatsPollFrequency);</span>
<span class="nc" id="L195">    }</span>

    private void connectInitialDevices() {
<span class="fc bfc" id="L198" title="All 2 branches covered.">        for (OpenFlowSwitch sw : controller.getSwitches()) {</span>
            try {
<span class="fc" id="L200">                listener.switchAdded(new Dpid(sw.getId()));</span>
<span class="nc" id="L201">            } catch (Exception e) {</span>
<span class="nc" id="L202">                LOG.warn(&quot;Failed initially adding {} : {}&quot;, sw.getStringId(), e.getMessage());</span>
<span class="nc" id="L203">                LOG.debug(&quot;Error details:&quot;, e);</span>
                // disconnect to trigger switch-add later
<span class="nc" id="L205">                sw.disconnectSwitch();</span>
<span class="fc" id="L206">            }</span>
<span class="fc" id="L207">            PortStatsCollector psc = new PortStatsCollector(sw, portStatsPollFrequency);</span>
<span class="fc" id="L208">            psc.start();</span>
<span class="fc" id="L209">            collectors.put(new Dpid(sw.getId()), psc);</span>
<span class="fc" id="L210">        }</span>
<span class="fc" id="L211">    }</span>

    private void disconnectDevices() {
        // Only disconnect the devices for which we are currently master.
<span class="pc" id="L215">        controller.getMasterSwitches().forEach(sw -&gt; listener.switchRemoved(new Dpid(sw.getId())));</span>
<span class="fc" id="L216">    }</span>

    @Override
    public boolean isReachable(DeviceId deviceId) {
<span class="nc" id="L220">        OpenFlowSwitch sw = controller.getSwitch(dpid(deviceId.uri()));</span>
<span class="nc bnc" id="L221" title="All 4 branches missed.">        return sw != null &amp;&amp; sw.isConnected();</span>
    }

    @Override
    public void triggerProbe(DeviceId deviceId) {
<span class="nc" id="L226">        LOG.debug(&quot;Triggering probe on device {}&quot;, deviceId);</span>

<span class="nc" id="L228">        final Dpid dpid = dpid(deviceId.uri());</span>
<span class="nc" id="L229">        OpenFlowSwitch sw = controller.getSwitch(dpid);</span>
<span class="nc bnc" id="L230" title="All 4 branches missed.">        if (sw == null || !sw.isConnected()) {</span>
<span class="nc" id="L231">            LOG.error(&quot;Failed to probe device {} on sw={}&quot;, deviceId, sw);</span>
<span class="nc" id="L232">            providerService.deviceDisconnected(deviceId);</span>
<span class="nc" id="L233">            return;</span>
        } else {
<span class="nc" id="L235">            LOG.trace(&quot;Confirmed device {} connection&quot;, deviceId);</span>
        }

        // Prompt an update of port information. We can use any XID for this.
<span class="nc" id="L239">        OFFactory fact = sw.factory();</span>
<span class="pc bnc" id="L240" title="All 3 branches missed.">        switch (fact.getVersion()) {</span>
            case OF_10:
<span class="nc" id="L242">                sw.sendMsg(fact.buildFeaturesRequest().setXid(0).build());</span>
<span class="nc" id="L243">                break;</span>
            case OF_13:
<span class="nc" id="L245">                sw.sendMsg(fact.buildPortDescStatsRequest().setXid(0).build());</span>
<span class="nc" id="L246">                break;</span>
            default:
<span class="nc" id="L248">                LOG.warn(&quot;Unhandled protocol version&quot;);</span>
        }
<span class="nc" id="L250">    }</span>

    @Override
    public void roleChanged(DeviceId deviceId, MastershipRole newRole) {
<span class="pc bpc" id="L254" title="1 of 4 branches missed.">        switch (newRole) {</span>
            case MASTER:
<span class="fc" id="L256">                controller.setRole(dpid(deviceId.uri()), RoleState.MASTER);</span>
<span class="fc" id="L257">                break;</span>
            case STANDBY:
<span class="fc" id="L259">                controller.setRole(dpid(deviceId.uri()), RoleState.EQUAL);</span>
<span class="fc" id="L260">                break;</span>
            case NONE:
<span class="fc" id="L262">                controller.setRole(dpid(deviceId.uri()), RoleState.SLAVE);</span>
<span class="fc" id="L263">                break;</span>
            default:
<span class="nc" id="L265">                LOG.error(&quot;Unknown Mastership state : {}&quot;, newRole);</span>

        }
<span class="fc" id="L268">        LOG.debug(&quot;Accepting mastership role change for device {}&quot;, deviceId);</span>
<span class="fc" id="L269">    }</span>

    private void pushPortMetrics(Dpid dpid, List&lt;OFPortStatsEntry&gt; portStatsEntries) {
<span class="nc" id="L272">        DeviceId deviceId = DeviceId.deviceId(dpid.uri(dpid));</span>
<span class="nc" id="L273">        Collection&lt;PortStatistics&gt; stats = buildPortStatistics(deviceId, portStatsEntries);</span>
<span class="nc" id="L274">        providerService.updatePortStatistics(deviceId, stats);</span>
<span class="nc" id="L275">    }</span>

    private Collection&lt;PortStatistics&gt; buildPortStatistics(DeviceId deviceId,
                                                           List&lt;OFPortStatsEntry&gt; entries) {
<span class="nc" id="L279">        HashSet&lt;PortStatistics&gt; stats = Sets.newHashSet();</span>

<span class="nc bnc" id="L281" title="All 2 branches missed.">        for (OFPortStatsEntry entry : entries) {</span>
            try {
<span class="nc bnc" id="L283" title="All 6 branches missed.">                if (entry == null || entry.getPortNo() == null || entry.getPortNo().getPortNumber() &lt; 0) {</span>
<span class="nc" id="L284">                    continue;</span>
                }
<span class="nc" id="L286">                DefaultPortStatistics.Builder builder = DefaultPortStatistics.builder();</span>
<span class="nc" id="L287">                DefaultPortStatistics stat = builder.setDeviceId(deviceId)</span>
<span class="nc" id="L288">                        .setPort(entry.getPortNo().getPortNumber())</span>
<span class="nc" id="L289">                        .setPacketsReceived(entry.getRxPackets().getValue())</span>
<span class="nc" id="L290">                        .setPacketsSent(entry.getTxPackets().getValue())</span>
<span class="nc" id="L291">                        .setBytesReceived(entry.getRxBytes().getValue())</span>
<span class="nc" id="L292">                        .setBytesSent(entry.getTxBytes().getValue())</span>
<span class="nc" id="L293">                        .setPacketsRxDropped(entry.getRxDropped().getValue())</span>
<span class="nc" id="L294">                        .setPacketsTxDropped(entry.getTxDropped().getValue())</span>
<span class="nc" id="L295">                        .setPacketsRxErrors(entry.getRxErrors().getValue())</span>
<span class="nc" id="L296">                        .setPacketsTxErrors(entry.getTxErrors().getValue())</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">                        .setDurationSec(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationSec())</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">                        .setDurationNano(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationNsec())</span>
<span class="nc" id="L299">                        .build();</span>

<span class="nc" id="L301">                stats.add(stat);</span>
<span class="nc" id="L302">            } catch (Exception e) {</span>
<span class="nc" id="L303">                LOG.warn(&quot;Unable to process port stats&quot;, e);</span>
<span class="nc" id="L304">            }</span>
<span class="nc" id="L305">        }</span>

<span class="nc" id="L307">        return Collections.unmodifiableSet(stats);</span>

    }

<span class="fc" id="L311">    private class InternalDeviceProvider implements OpenFlowSwitchListener, OpenFlowEventListener {</span>

<span class="fc" id="L313">        private HashMap&lt;Dpid, List&lt;OFPortStatsEntry&gt;&gt; portStatsReplies = new HashMap&lt;&gt;();</span>

        @Override
        public void switchAdded(Dpid dpid) {
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">            if (providerService == null) {</span>
<span class="nc" id="L318">                return;</span>
            }
<span class="fc" id="L320">            DeviceId did = deviceId(uri(dpid));</span>
<span class="fc" id="L321">            OpenFlowSwitch sw = controller.getSwitch(dpid);</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">            if (sw == null) {</span>
<span class="nc" id="L323">                return;</span>
            }

<span class="fc" id="L326">            ChassisId cId = new ChassisId(dpid.value());</span>

<span class="fc" id="L328">            SparseAnnotations annotations = DefaultAnnotations.builder()</span>
<span class="fc" id="L329">                    .set(AnnotationKeys.PROTOCOL, sw.factory().getVersion().toString())</span>
<span class="fc" id="L330">                    .set(AnnotationKeys.CHANNEL_ID, sw.channelId())</span>
<span class="fc" id="L331">                    .set(AnnotationKeys.MANAGEMENT_ADDRESS, sw.channelId().split(&quot;:&quot;)[0])</span>
<span class="fc" id="L332">                    .build();</span>

<span class="fc" id="L334">            DeviceDescription description =</span>
<span class="fc" id="L335">                    new DefaultDeviceDescription(did.uri(), sw.deviceType(),</span>
<span class="fc" id="L336">                                                 sw.manufacturerDescription(),</span>
<span class="fc" id="L337">                                                 sw.hardwareDescription(),</span>
<span class="fc" id="L338">                                                 sw.softwareDescription(),</span>
<span class="fc" id="L339">                                                 sw.serialNumber(),</span>
                                                 cId, annotations);
<span class="fc" id="L341">            providerService.deviceConnected(did, description);</span>
<span class="fc" id="L342">            providerService.updatePorts(did, buildPortDescriptions(sw));</span>

<span class="fc" id="L344">            PortStatsCollector psc =</span>
<span class="fc" id="L345">                    new PortStatsCollector(sw, portStatsPollFrequency);</span>
<span class="fc" id="L346">            psc.start();</span>
<span class="fc" id="L347">            collectors.put(dpid, psc);</span>

            //figure out race condition for collectors.remove() and collectors.put()
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            if (controller.getSwitch(dpid) == null) {</span>
<span class="nc" id="L351">                switchRemoved(dpid);</span>
            }
<span class="fc" id="L353">        }</span>

        @Override
        public void switchRemoved(Dpid dpid) {
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">            if (providerService == null) {</span>
<span class="nc" id="L358">                return;</span>
            }
<span class="fc" id="L360">            providerService.deviceDisconnected(deviceId(uri(dpid)));</span>

<span class="fc" id="L362">            PortStatsCollector collector = collectors.remove(dpid);</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">            if (collector != null) {</span>
<span class="fc" id="L364">                collector.stop();</span>
            }
<span class="fc" id="L366">        }</span>

        @Override
        public void switchChanged(Dpid dpid) {
<span class="nc bnc" id="L370" title="All 2 branches missed.">            if (providerService == null) {</span>
<span class="nc" id="L371">                return;</span>
            }
<span class="nc" id="L373">            DeviceId did = deviceId(uri(dpid));</span>
<span class="nc" id="L374">            OpenFlowSwitch sw = controller.getSwitch(dpid);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            if (sw == null) {</span>
<span class="nc" id="L376">                return;</span>
            }
<span class="nc" id="L378">            providerService.updatePorts(did, buildPortDescriptions(sw));</span>
<span class="nc" id="L379">        }</span>

        @Override
        public void portChanged(Dpid dpid, OFPortStatus status) {
<span class="fc" id="L383">            PortDescription portDescription = buildPortDescription(status);</span>
<span class="fc" id="L384">            providerService.portStatusChanged(deviceId(uri(dpid)), portDescription);</span>
<span class="fc" id="L385">        }</span>

        @Override
        public void receivedRoleReply(Dpid dpid, RoleState requested, RoleState response) {
<span class="fc" id="L389">            MastershipRole request = roleOf(requested);</span>
<span class="fc" id="L390">            MastershipRole reply = roleOf(response);</span>
<span class="fc" id="L391">            providerService.receivedRoleReply(deviceId(uri(dpid)), request, reply);</span>
<span class="fc" id="L392">        }</span>

        /**
         * Translates a RoleState to the corresponding MastershipRole.
         *
         * @param response role state
         * @return a MastershipRole
         */
        private MastershipRole roleOf(RoleState response) {
<span class="pc bpc" id="L401" title="1 of 4 branches missed.">            switch (response) {</span>
                case MASTER:
<span class="fc" id="L403">                    return MastershipRole.MASTER;</span>
                case EQUAL:
<span class="fc" id="L405">                    return MastershipRole.STANDBY;</span>
                case SLAVE:
<span class="fc" id="L407">                    return MastershipRole.NONE;</span>
                default:
<span class="nc" id="L409">                    LOG.warn(&quot;unknown role {}&quot;, response);</span>
<span class="nc" id="L410">                    return null;</span>
            }
        }

        /**
         * Builds a list of port descriptions for a given list of ports.
         *
         * @return list of portdescriptions
         */
        private List&lt;PortDescription&gt; buildPortDescriptions(OpenFlowSwitch sw) {
<span class="fc" id="L420">            final List&lt;PortDescription&gt; portDescs = new ArrayList&lt;&gt;(sw.getPorts().size());</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">            if (!(Device.Type.ROADM.equals(sw.deviceType()))) {</span>
<span class="fc" id="L422">                  sw.getPorts().forEach(port -&gt; portDescs.add(buildPortDescription(port)));</span>
            }

            OpenFlowOpticalSwitch opsw;
<span class="pc bpc" id="L426" title="2 of 3 branches missed.">            switch (sw.deviceType()) {</span>
                case ROADM:
<span class="nc" id="L428">                    opsw = (OpenFlowOpticalSwitch) sw;</span>
<span class="nc" id="L429">                    List&lt;OFPortDesc&gt; ports = opsw.getPorts();</span>
<span class="nc" id="L430">                    LOG.debug(&quot;SW ID {} , ETH- ODU CLT Ports {}&quot;, opsw.getId(), ports);</span>
                    // ODU client ports are reported as ETH
<span class="nc" id="L432">                    ports.forEach(port -&gt; portDescs.add(buildOduCltPortDescription(port)));</span>

<span class="nc" id="L434">                    opsw.getPortTypes().forEach(type -&gt; {</span>
<span class="nc" id="L435">                    List&lt;? extends OFObject&gt; portsOf = opsw.getPortsOf(type);</span>
<span class="nc" id="L436">                    LOG.debug(&quot;Ports Of{}&quot;, portsOf);</span>
<span class="nc" id="L437">                    portsOf.forEach(</span>
                        op -&gt; {
<span class="nc" id="L439">                            portDescs.add(buildPortDescription(type, (OFObject) op));</span>
<span class="nc" id="L440">                        }</span>
                     );
<span class="nc" id="L442">                    });</span>
<span class="nc" id="L443">                    break;</span>
                case FIBER_SWITCH:
<span class="nc" id="L445">                    opsw = (OpenFlowOpticalSwitch) sw;</span>
<span class="nc" id="L446">                    opsw.getPortTypes().forEach(type -&gt; {</span>
<span class="nc" id="L447">                        opsw.getPortsOf(type).forEach(</span>
                                op -&gt; {
<span class="nc" id="L449">                                    portDescs.add(buildPortDescription((OFCalientPortDescStatsEntry) op));</span>
<span class="nc" id="L450">                                }</span>
                        );
<span class="nc" id="L452">                    });</span>
<span class="nc" id="L453">                    break;</span>
                default:
                    break;
            }

<span class="fc" id="L458">            return portDescs;</span>
        }

        private PortDescription buildOduCltPortDescription(OFPortDesc port) {
<span class="nc" id="L462">            PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">            boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN) &amp;&amp;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                              !port.getConfig().contains(OFPortConfig.PORT_DOWN);</span>
<span class="nc" id="L465">            Long portSpeed = portSpeed(port);</span>
<span class="nc" id="L466">            OduCltPort.SignalType sigType = null;</span>

<span class="nc bnc" id="L468" title="All 18 branches missed.">            switch (portSpeed.toString()) {</span>
                case &quot;1&quot;:
<span class="nc" id="L470">                    sigType = OduCltPort.SignalType.CLT_1GBE;</span>
<span class="nc" id="L471">                    break;</span>
                case &quot;10&quot;:
<span class="nc" id="L473">                    sigType = OduCltPort.SignalType.CLT_10GBE;</span>
<span class="nc" id="L474">                    break;</span>
                case &quot;40&quot;:
<span class="nc" id="L476">                    sigType = OduCltPort.SignalType.CLT_40GBE;</span>
<span class="nc" id="L477">                    break;</span>
                case &quot;100&quot;:
<span class="nc" id="L479">                    sigType = OduCltPort.SignalType.CLT_100GBE;</span>
<span class="nc" id="L480">                    break;</span>
                default:
<span class="nc" id="L482">                    throw new RuntimeException(&quot;Un recognize OduClt speed: &quot; + portSpeed.toString());</span>
            }

<span class="nc" id="L485">            SparseAnnotations annotations = buildOduCltAnnotation(port);</span>
<span class="nc" id="L486">            return new OduCltPortDescription(portNo, enabled, sigType, annotations);</span>
        }

        private SparseAnnotations buildOduCltAnnotation(OFPortDesc port) {
<span class="nc" id="L490">            SparseAnnotations annotations = null;</span>
<span class="nc" id="L491">            String portName = Strings.emptyToNull(port.getName());</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">            if (portName != null) {</span>
<span class="nc" id="L493">                 annotations = DefaultAnnotations.builder()</span>
<span class="nc" id="L494">                        .set(AnnotationKeys.PORT_NAME, portName)</span>
<span class="nc" id="L495">                        .set(AnnotationKeys.STATIC_PORT, Boolean.TRUE.toString()).build();</span>
            }
<span class="nc" id="L497">            return annotations;</span>
        }

        private PortDescription buildPortDescription(PortDescPropertyType ptype, OFObject port) {
<span class="nc bnc" id="L501" title="All 2 branches missed.">            if (port instanceof  OFPortOptical) {</span>
<span class="nc" id="L502">               return buildPortDescription(ptype, (OFPortOptical) port);</span>
            }
<span class="nc" id="L504">            return buildPortDescription(ptype, (OFExpPort) port);</span>
        }

        /**
         * Build a portDescription from a given a port description describing some
         * Optical port.
         *
         * @param ptype description property type.
         * @param port the port to build from.
         * @return portDescription for the port.
         */
        private PortDescription buildPortDescription(PortDescPropertyType ptype, OFExpPort port) {
<span class="nc" id="L516">            PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">            boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN)</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">                    &amp;&amp; !port.getConfig().contains(OFPortConfig.PORT_DOWN);</span>
<span class="nc" id="L519">            SparseAnnotations annotations = makePortNameAnnotation(port.getName());</span>

<span class="nc" id="L521">            OFExpPortDescPropOpticalTransport firstProp = port.getProperties().get(0);</span>
<span class="nc" id="L522">            OFPortOpticalTransportSignalType sigType = firstProp.getPortSignalType();</span>

<span class="nc" id="L524">            DefaultPortDescription portDes = null;</span>
<span class="pc bnc" id="L525" title="All 4 branches missed.">            switch (sigType) {</span>
            case OMSN:
<span class="nc" id="L527">                portDes =  new OmsPortDescription(portNo, enabled, FREQ193_1, FREQ193_1.add(FREQ4_4),</span>
<span class="nc" id="L528">                       FREQ100, annotations);</span>
<span class="nc" id="L529">                break;</span>
            case OCH:
<span class="nc" id="L531">                OFExpPortOpticalTransportLayerEntry entry = firstProp.getFeatures().get(0).getValue().get(0);</span>
<span class="nc" id="L532">                OFPortOpticalTransportLayerClass layerClass =  entry.getLayerClass();</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">                if (!OFPortOpticalTransportLayerClass.ODU.equals(layerClass)) {</span>
<span class="nc" id="L534">                    LOG.error(&quot;Unsupported layer Class {} &quot;, layerClass);</span>
<span class="nc" id="L535">                    return null;</span>
                }

                // convert to ONOS OduSignalType
<span class="nc" id="L539">                OduSignalType oduSignalType = OpenFlowDeviceValueMapper.</span>
<span class="nc" id="L540">                        lookupOduSignalType((byte) entry.getSignalType());</span>
                //OchSignal is needed for OchPortDescription constructor,
                //yet not relevant for tunable OCH port, creating with default parameters
<span class="nc" id="L543">                OchSignal signalId = new OchSignal(GridType.DWDM, ChannelSpacing.CHL_50GHZ, 1, 1);</span>

<span class="nc" id="L545">                portDes = new OchPortDescription(portNo, enabled,</span>
                        oduSignalType, true, signalId, annotations);

<span class="nc" id="L548">                break;</span>
            case OTU2:
            case OTU4:
<span class="nc" id="L551">                  LOG.error(&quot;Signal tpye OTU2/4 not supported yet &quot;, port.toString());</span>
<span class="nc" id="L552">                  break;</span>
            default:
                break;
            }

<span class="nc" id="L557">            return portDes;</span>
        }

        /**
         * Creates an annotation for the port name if one is available.
         *
         * @param port description of the port
         * @return annotation containing the port name if one is found,
         *         null otherwise
         */
        private SparseAnnotations makePortNameAnnotation(String port) {
<span class="fc" id="L568">            SparseAnnotations annotations = null;</span>
<span class="fc" id="L569">            String portName = Strings.emptyToNull(port);</span>
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">            if (portName != null) {</span>
<span class="nc" id="L571">                annotations = DefaultAnnotations.builder()</span>
<span class="nc" id="L572">                        .set(AnnotationKeys.PORT_NAME, portName).build();</span>
            }
<span class="fc" id="L574">            return annotations;</span>
        }

        /**
         * Build a portDescription from a given Ethernet port description.
         *
         * @param port the port to build from.
         * @return portDescription for the port.
         */
        private PortDescription buildPortDescription(OFPortDesc port) {
<span class="fc" id="L584">            PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());</span>
<span class="fc" id="L585">            boolean enabled =</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">                    !port.getState().contains(OFPortState.LINK_DOWN) &amp;&amp;</span>
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">                            !port.getConfig().contains(OFPortConfig.PORT_DOWN);</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">            Port.Type type = port.getCurr().contains(OFPortFeatures.PF_FIBER) ? FIBER : COPPER;</span>
<span class="fc" id="L589">            SparseAnnotations annotations = makePortNameAnnotation(port.getName());</span>
<span class="fc" id="L590">            return new DefaultPortDescription(portNo, enabled, type,</span>
<span class="fc" id="L591">                                              portSpeed(port), annotations);</span>
        }

        /**
         * Build a portDescription from a given a port description describing some
         * Optical port.
         *
         * @param port description property type.
         * @param port the port to build from.
         * @return portDescription for the port.
         */
        private PortDescription buildPortDescription(PortDescPropertyType ptype, OFPortOptical port) {
<span class="nc bnc" id="L603" title="All 2 branches missed.">            checkArgument(port.getDesc().size() &gt;= 1);</span>

            // Minimally functional fixture. This needs to be fixed as we add better support.
<span class="nc" id="L606">            PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());</span>

<span class="nc bnc" id="L608" title="All 2 branches missed.">            boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN)</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">                    &amp;&amp; !port.getConfig().contains(OFPortConfig.PORT_DOWN);</span>
<span class="nc" id="L610">            SparseAnnotations annotations = makePortNameAnnotation(port.getName());</span>

<span class="nc bnc" id="L612" title="All 4 branches missed.">            if (port.getVersion() == OFVersion.OF_13</span>
                    &amp;&amp; ptype == PortDescPropertyType.OPTICAL_TRANSPORT) {
                // At this point, not much is carried in the optical port message.
<span class="nc" id="L615">                LOG.debug(&quot;Optical transport port message {}&quot;, port.toString());</span>
            } else {
                // removable once 1.4+ support complete.
<span class="nc" id="L618">                LOG.debug(&quot;Unsupported optical port properties&quot;);</span>
            }

<span class="nc" id="L621">            OFPortDescPropOpticalTransport desc = port.getDesc().get(0);</span>
<span class="nc bnc" id="L622" title="All 3 branches missed.">            switch (desc.getPortSignalType()) {</span>
                // FIXME: use constants once loxi has full optical extensions
                case 2:     // OMS port
                    // Assume complete optical spectrum and 50 GHz grid
                    // LINC-OE is only supported optical OF device for now
<span class="nc" id="L627">                    return new OmsPortDescription(portNo, enabled,</span>
<span class="nc" id="L628">                            Spectrum.U_BAND_MIN, Spectrum.O_BAND_MAX, Frequency.ofGHz(50), annotations);</span>
                case 5:     // OCH port
<span class="nc" id="L630">                    OchSignal signal = new OchSignal(GridType.DWDM, ChannelSpacing.CHL_50GHZ, 0, 4);</span>
<span class="nc" id="L631">                    return new OchPortDescription(portNo, enabled, OduSignalType.ODU4,</span>
                            true, signal, annotations);
                default:
                    break;
            }

<span class="nc" id="L637">            return new DefaultPortDescription(portNo, enabled, FIBER, 0, annotations);</span>
        }

        /**
         * Build a portDescription from a given port description describing a fiber switch optical port.
         *
         * @param port description property type.
         * @param port the port to build from.
         * @return portDescription for the port.
         */
        private PortDescription buildPortDescription(OFCalientPortDescStatsEntry port) {
<span class="nc" id="L648">            PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());</span>

            // FIXME when Calient OF agent reports port status
<span class="nc" id="L651">            boolean enabled = true;</span>
<span class="nc" id="L652">            SparseAnnotations annotations = makePortNameAnnotation(port.getName());</span>

            // S160 data sheet
            // Wavelength range: 1260 - 1630 nm, grid is irrelevant for this type of switch
<span class="nc" id="L656">            return new OmsPortDescription(portNo, enabled,</span>
<span class="nc" id="L657">                    Spectrum.U_BAND_MIN, Spectrum.O_BAND_MAX, Frequency.ofGHz(100), annotations);</span>
        }

        private PortDescription buildPortDescription(OFPortStatus status) {
<span class="fc" id="L661">            OFPortDesc port = status.getDesc();</span>
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">            if (status.getReason() != OFPortReason.DELETE) {</span>
<span class="fc" id="L663">                return buildPortDescription(port);</span>
            } else {
<span class="nc" id="L665">                PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                Port.Type type = port.getCurr().contains(OFPortFeatures.PF_FIBER) ? FIBER : COPPER;</span>
<span class="nc" id="L667">                SparseAnnotations annotations = makePortNameAnnotation(port.getName());</span>
<span class="nc" id="L668">                return new DefaultPortDescription(portNo, false, type,</span>
<span class="nc" id="L669">                                                  portSpeed(port), annotations);</span>
            }
        }

        private long portSpeed(OFPortDesc port) {
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">            if (port.getVersion() == OFVersion.OF_13) {</span>
<span class="nc" id="L675">                return port.getCurrSpeed() / MBPS;</span>
            }

<span class="fc" id="L678">            PortSpeed portSpeed = PortSpeed.SPEED_NONE;</span>
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">            for (OFPortFeatures feat : port.getCurr()) {</span>
<span class="nc" id="L680">                portSpeed = PortSpeed.max(portSpeed, feat.getPortSpeed());</span>
<span class="nc" id="L681">            }</span>
<span class="fc" id="L682">            return portSpeed.getSpeedBps() / MBPS;</span>
        }

        @Override
        public void handleMessage(Dpid dpid, OFMessage msg) {
<span class="pc bnc" id="L687" title="All 2 branches missed.">            switch (msg.getType()) {</span>
                case STATS_REPLY:
<span class="nc bnc" id="L689" title="All 2 branches missed.">                    if (((OFStatsReply) msg).getStatsType() == OFStatsType.PORT) {</span>
<span class="nc" id="L690">                        OFPortStatsReply portStatsReply = (OFPortStatsReply) msg;</span>
<span class="nc" id="L691">                        List&lt;OFPortStatsEntry&gt; portStatsReplyList = portStatsReplies.get(dpid);</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                        if (portStatsReplyList == null) {</span>
<span class="nc" id="L693">                            portStatsReplyList = Lists.newArrayList();</span>
                        }
<span class="nc" id="L695">                        portStatsReplyList.addAll(portStatsReply.getEntries());</span>
<span class="nc" id="L696">                        portStatsReplies.put(dpid, portStatsReplyList);</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">                        if (!portStatsReply.getFlags().contains(OFStatsReplyFlags.REPLY_MORE)) {</span>
<span class="nc" id="L698">                            pushPortMetrics(dpid, portStatsReplies.get(dpid));</span>
<span class="nc" id="L699">                            portStatsReplies.get(dpid).clear();</span>
                        }
<span class="nc" id="L701">                    }</span>
                    break;
                default:
                    break;
            }
<span class="nc" id="L706">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>